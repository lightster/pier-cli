#!/usr/bin/env ruby

require "thor"

class Pier < Thor
  desc "install GITHUB_REPO", "install GITHUB_REPO"
  def install(repo)
    namespaced_repo = repo.sub('/', '.')

    codebase_dir = "/codebase"
    repo_dir = "#{codebase_dir}/#{namespaced_repo}"

    if !Dir.exist?(repo_dir) then
      git_output = %x(
        cd "#{codebase_dir}" \
          && git clone git@github.com:#{repo}.git "#{repo_dir}" 2>&1
      )

      if $?.exitstatus != 0 then
        STDERR.puts "Error while cloning #{repo}:\n#{git_output}"
      end
    end

    if File.exist?("#{repo_dir}/configure") then
      configure_output = %x(
        cd "#{repo_dir}" \
          && ./configure docker
      )

      if $?.exitstatus != 0 then
        STDERR.puts "Error while running \`./configure docker\`:\n#{configure_output}"
      end
    end

    if File.exist?("#{repo_dir}/Makefile") then
      make_output = %x(
        cd '#{repo_dir}' \
          && make install
      )

      if $?.exitstatus != 0 then
        STDERR.puts "Error while running \`make install\`:\n#{make_output}"
        exit 1
      end
    end
  end

  desc "test PROJECT_NAME", "run tests for PROJECT"
  def test(project)
    project_dir = getProjectDir(project)

    if File.exist?("#{project_dir}/Makefile") then
      exec("
        cd '#{project_dir}' \
          && make test 1>&2
      ")
    end
  end

  private

  def getProjectDir(project)
    codebase_dir = "/codebase"

    repo_dir = "#{codebase_dir}/#{project}"
    if Dir.exists?(repo_dir) then
      return repo_dir
    end

    repo_pattern = "#{codebase_dir}/*.#{project}"
    matches = Dir.glob(repo_pattern)
    if matches.length == 1 then
      return matches[0]
    elsif matches.length >= 1
      STDERR.puts "Multiple projects match the given project name:"
      matches.each do |path|
        match = path.sub!("#{codebase_dir}/", '')
        STDERR.puts " - #{match}"
      end
      STDERR.puts "\nPlease use a full qualified project name."
      exit 1
    end

    STDERR.puts "No projects match '#{project}'"
    exit 1
  end
end

Pier.start(ARGV)
